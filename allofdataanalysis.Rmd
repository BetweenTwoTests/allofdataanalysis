--- 
title: "All of Data Analysis"
subtitle: "An Expansive Course in Statistical Analysis" 
author: "Leon Kim"
date: "`r Sys.Date()`"
site: "bookdown::bookdown_site"
output:
  bookdown::gitbook:
    lib_dir: "book_assets"
documentclass: book
bibliography: [book.bib]
biblio-style: apalike
link-citations: yes
github-repo: BetweenTwoTests/betweentwotests-book
url: 'http\://betweentwotests.com/allofdataanalysis/'
description: "All of Data Analysis"
---


```{r setup, eval=TRUE, echo=FALSE}
# Default setting
# knitr::opts_chunk$set(comment = "  ", eval=TRUE, echo=FALSE)
```

# About {-}

This is a reproduction of my study notes & exercises from various points of my academic and professional career in statistics. Please excuse the grandiose title. (Fans of statistics should note that the title is tongue-in-cheek reference to [this equally grandiose book title](https://www.google.com/search?q=all+of+statistics&oq=all+of+statistics) )

The contents here are not meant to replace existing statistics textbooks. They are meant to fill in some of the gaps, especially in context of psychometrics.
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:index.Rmd-->

# Introduction
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/01-Introduction/01-00-introduction.Rmd-->

## Hypothesis

Some important terms & definitions

<h3>What is the purpose of statistics?</h3>

estimate / predict / simplify / organize data

<h3>Law</h3>

a rule that implies cause and effect between anything and that applies under same conditions every time.

&nbsp;&nbsp;&nbsp;&nbsp;i.e. under some conditions, we can predict what happens all the time

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;but this does not explain "why" the observed cause and effect events happen

<h3>Model</h3>

an idealization of the world

<h3>Hypothesis</h3>

**falsifiable** statement regarding the **true state** of the world

&nbsp;&nbsp;&nbsp;&nbsp;true state: assumption that some regularity exists (i.e. law of nature)

- Hypothesis is supported or refuted by evidence, **never proven to be true**.

- Hypothesis is a positive statement of a question.

- Error is assumed to be present

---

**Science proves in negative direction**. Our understanding of the world changes by showing that the existing scientific _"fact"_ is _"false"_ and other **_alternative hypotheses_** are better candidates to explain the observed events. Let's call this currently accepted hypothesis as **_null hypothesis_** and showing that null hypothesis is _"false"_ as **_rejecting the null hypothesis_**. (The words _"fact"_ and _"false"_ are purposely italicized to denote that these terms do not note certainty). You can optionally thing of this as a hypothesis to "null"-ify or a hypothesis of 0 case, null case etc. (one of many words that mean "nothing"). The former "nullify" might make more sense than the "nothing" case if you have no prior exposure to statistics. We will see why the later case is a more popular case of thinking of the null hypothesis.

---

Saying that there are many other alternative hypothesis that could be shown as the better candidate for observed data (1-vs-many case) is more difficult to reason about compared to a simpler, 1-vs-1 case. What if we state our null hypothesis and alternative hypothesis in a way that it is a choice between one or another? i.e. _either_ null hypothesis _or_ alternative hypothesis is a better explanation of the observed data. This is the idea behind how null hypotheses are commonly formulated.

Actually, let's define 3 types of hypothesis

1. _(Scientific) Research Hypothesis_  
This is a research question of interested in words, propositions, statements etc. that can be falsified by data. This question does not necessarily have to be quantitative in nature.

2. _(Statistical) Null Hypothesis_  
Since we can't _"prove true"_ in statistics, this is the _nullifiable_ hypothesis that is generally assumed to be true until data shows otherwise.  
e.g. presumed innocent until guilty.  
<br/>
Note that this is can be a re-wording of Research Hypothesis. A Null Hypothesis is generally the default position that there is no relationship between two measured phenomena. Similarly, the default position can be that there are no association among groups of observed values. (Null hypothesis does not necessarily have to be "no" effect. More on this later). We usually denote this with the symbol and equation $H_0$ and formalized as an equation, for example $\text{effect} = 0$. The word "null" here is taking on both verb and adjective forms in Null Hypothesis.

3. _(Statistical) Alternative Hypothesis_ 
Since science proves in negative direction, this is the _"case B"_ scenario when the data collected suggests that we should **_reject_** the **_null_** hypothesis in favor of the alternative. Null hypothesis and alternative hypothesis are mutually exclusive -- i.e. if we ever knew what the absolute true state of the world, that absolute truth will be one or the other but not both. We usually denote this with the symbol $H_a$ and formalized as an equation that is negation of the corresponding null hypothesis, for example $\text{effect} \neq 0$.  
<br/>The Alternative hypothesis often formulated as the algebraic complement of the null hypothesis. Hence, you will see it stated often as $\neq$ (compared to null hypothesis of $=$). This satisfies the mutual exclusivity requirement. But note that mutual exclusivity does not necessarily imply that null and alternative hypothesis taken together have to account for _all_ possibility.  
  
---

Whether we choose $\neq$, $<$, or $>$ is related to the statistical technique we use. More on this later, but it should be noted that statistics does not guide the alternative hypothesis. It should be guided by the research hypothesis.    


<h4>Formulating the hypothesis</h4>

A cursory look would imply that $H_0$ is always "something equals nothing" and $H_a$ is "something equals not-nothing". But this isn't always true, as we see in the example. See [answer to "How to choose the null and alternative hypothesis?" in Cross Validated Forum for more](https://stats.stackexchange.com/a/123304/183622)

The way that $H_0$ and $H_a$ are stated in textbooks suggest that you should form the null hypotheis comes first, then the alternative hypothesis. Although this can get you the right answer, the more suitable direction is $H_a \rightarrow  H_0$. The initial starting point of $H_a$ should be guided by your (scientific) Research Hypothesis. The $H_0$ is often the complement of $H_a$ or more often $H_0: something = 0$, but it doesn't have to be. The "null" in Null Hypothesis doesn't mean $= 0$. It means the $something$ you wanted is not present, which often is $= 0$ but not always.

We often want to see evidence against the null, and this aligns well with the fact that what we want to establish evidence for the Research Hypothesis / Alternative Hypothesis.  

There are cases where we **do not want to** reject the null. These scenarios are when we finding modeling something. We will see example of this later on as well.




```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/01-Introduction/01-01-hypothesis.Rmd-->

## Examples of $H_0$

Examples to clarify null hypothesis:

Your friend claims that he is very good at guessing the answer to a 5-choice multiple choice questions. If given the chance, he claims that he can guess at every single question without even looking at the question and its choices (which would create a random guessing scenario without him being able to eliminate some of the choices to make "educated guessing"). You are obviously don't believe that he will be able to get all answers correct, so you give him a test with 10 questions, each with 5 choices.  
  
- What is the null hypothesis?

In this test where you friend randomly guessed at all 10 questions, you would expect him to get approximately 20% correct. This is your default case, driven by what you know about basic probability. So you state that $H_0: p = \frac{1}{5}$ where $p$ is the percentage score for your test.

- What is the alternative hypothesis?

If we followed the conventional wisdom of stating the alternative as complement of the null, then $H_a: p \neq \frac{1}{5}$. You run your experiment and collect the result as $p_{friend}$. You plug these 3 pieces of information to your favorite statistics software **_cough_** _R_ **_cough_** and gets the result of your hypothesis test using _statistics_. (You actually would need more than these 3 pieces of information. More on that later too). The software says says "reject the null hypothesis and accept the alternative hypothesis". You are in shock. Maybe statistic technique you used was wrong?  Maybe he was telling the truth and he is a clairvoyant who knows the answers to everything. You start to have existential crisis.

But wait, take a look at the $H_a$. It says the test score is not equal to $1/5$. Under this alternative hypothesis, your friend could have gotten all the questions wrong or all the questions right. The former would imply he is not a clairvoyant while the latter does imply he is. Stated in terms of formula, our alternative hypothesis could also be $H_a: p < \frac{1}{5}$ or $H_a: p > \frac{1}{5}$. Since we are looking for evidence that your friend is clairvoyant, we should have used the latter alternative hypothesis.

You run your statistical software again with the new alternative hypothesis, $H_a: p > \frac{1}{5}$. The software says "failed to reject the null hypothesis". Your friend is in an uproar and accurse of being a statistical hack. ~Clearly both of you must enroll in graduate program in statistics to figure out who is right.~
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/01-Introduction/01-02-examples.Rmd-->

## Research Design

```{r 01-03-setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(kableExtra)
```


We assume that the universe is orderly, and events have specific causes. We use the scientific method to study the universe

<h3>The General Procedures for the Scientific Method</h3>

1. Ask a question about the world and identify relevant terms needed to ask the question.

2. Operationalize the relevant terms.
_"Operationalize"_: a concept defined by how we measure the terms of interest. Usually involves putting a number on an abstract concept, but doesn't have to be a number either.

3. Pick a research method

4. Collect & analyze data
   
<h3> Research Methods </h3>

These differ in the kinds of information about behavior they yield, as well as in the types of behavior to which they are best suited for studying. We will look at five different methods. Note that they are not mutually exclusive.

1. **Observational** It is a systematic method for observing behavior as it naturally occurs.
<br/>aka systemic observation or naturalistic observation.
 This method is characterized by:
<br/>
    - **Unobtrusiveness** - subjects are unaware that they are being observed
    - **Naturalness** - subjects are "at home" and thus assumed to behave as natural as possible
    - **Systematic Recording** - Behavior is measure and/or counted.
<br/>
For example,  
&nbsp;_frequencies_ : how many  
&nbsp;_duration_ : how long  
&nbsp;_latentcies_ : how long until  
etc. are recorded for operationally defined behaviors  
<br/>
Since researchers are observing and measuring behaviors, there might be differences between observers in agreement. The measure of how reliable operationalized measures are called, unsurprisingly, _reliability_.

2. **Surveys**
Gathering a information through questionaires, interviews, etc. on a subset of population of interest. This method is characterized by:
<br/>
    - Sampling a subset of population and measuring these subset (since measuring the whole population is impossible and/or prohibitively costly)
<br/>
Things to consider:
<br/>
- **Sampling adequacy**

3. **Case Studies**
An individual or small group of individuals of interest is studied in detail. These individuals or small group of individualsare called a _cohort_. This is characterized by two main ways of performing case studies:
<br/>
    - **Retrospective** - looks back at past events of the cohorts.
<br/>
Note that we never measured anything in the past. We ask the individuals (and/or people around them, if relevant to the study) about the cohort's past behaviors. The reliability of this sort of data also depends on the ability for the subject to recall memories.
    - **Longitudinal** or **Proactive** - follow events as they occur.
<br/>We first identify cohorts and continue to study the same cohort for some period of time. This sort of data are very accurate but very costly to do in large scale. Note that many individuals in the cohorts are expected to fall out of the study, so we would have to start with large population. If we are studying a condition that occurs at adulthood and are interested in measuring since birth but we don't know if a baby would have this condition in the future, then we would have to appropriately have very large cohort to increase our likelihood of capturing individuals of interest by the end of the study.
<br/><br/>
For example schizophrenia that occurs about 1% of the population between age 15 and 35. We want to have 10 subjects with schizophrenia at the end of 35 year study. We should start with 1000 babies and hope for the best that no one drops out (unrealistic, for sure).

4. **Experimental Method**
This is what we most likely are talking about when we say an "experiment to test effect of X on Y". If randomized control trial (RCT) is used, then this method can provide strong evidence for cause & effect.
<br/>
    - **Independent Variable** (IV) - Variable that we can select and manipulate.
<br/>IV must have at least two levels (categorical) or values (numerical) that IV can take. If IV has only one level or value, then that IV is not useful at all.
    - **Dependent Variable** (DV) - Variable that we measure and is interested in making inferences about. Sometimes callec _criterion variable_.
    - **Extraneous Variable** (EV) - Variable other than IV that can influence the DV. If an EV effects the groups in an experiment (groups determined by the levels of IV, e.g. `treatment` IV with levels `control` and `drug`), then we do not know whether changes in DV are explained by IV or EV. Usually both IVs and EVs effect the variability in DV, and we call such Evs _confounding_ variable. Table \@ref(tab:01-03-ev-table) shows possible effects of EV on DV. Pay close attention to the effect on groups created by IV (e.g. `control` and `drug`). 
<br/>

```{r 01-03-ev-table, echo=FALSE}
ev_table <- tribble(
    ~`Possible Effect on DV`, ~`Is it a problem?`, ~`Statistical term`,
    "EV has no effect on either groups", "Not a problem", "?",
    "EV effects all the groups in the same manner", "Not a problem", "fixed effect (?)",
    "EV effects groups differentially based on which level the subject belongs to", "Not a problem", "interaction effect (?)"
)
col_width <- c("4.5 in", "2 in", "2 in")
kable(
  ev_table, booktabs = T,
  caption = '<br/>EV & IV on DV',
) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>% 
  column_spec(seq_along(ev_table), width = col_width, width_min = col_width, width_max = col_width)
```

<p style="margin-left: 40px;">PS Under certain designs, we could say IV _*effects*_ DV with the word _effect_ as a verb to mean IV "results in or brings about change or consequence" to note cause & effect as apposed to _affect_ which is less stringent and to mean that IV "influences changes in" DV. Nitpicky for sure, but an important distinction. I am assuming that the experimental method would satisfy the condtions for the strong claim of _effect_.
</p>

---

https://www4.uwsp.edu/psych/mp/c/p300.htm
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/01-Introduction/01-03-research-design.Rmd-->

## Factors and Groups

```{r 01-04-setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(kableExtra)
```

You often see terms like _between-subject_ and _within-subject_ What are they and how do they relate to experiment design?


<h3>One IV vs DV</h3>

Subjects are measured on DV and belongs to one of two groups as denoted by IV level value. In this example, IV, let's say `treatment`, has two levels: _control_ and _experiment_. If there are more than 2 levels (e.g. subject belongs to one of three levels _control_, _experiment 1_, or _experiment 2_), then such experiment would still fall under "one IV" case.
<br/>
<br/>
In a table representation, the cell values are generally the average $\overline{y}$ of the measured DV (where $y$ is the DV). The subscripts distinguish which subject ($i$) and groups ($j$) the variable $y_{ij}$ refers to.

- For example, for an experiment with $n_1$ number of subjects in `Group 1` ($j = 1$) and $n_2$ number of subjects in `Group 2` ($j = 2$), <br/>
there are $\langle y_{1,1}, y_{2,1}, y_{3,1}, ..., y_{n_1, 1}\rangle$ measurements associated with subjects in `Group 1`, and <br/>
there are $\langle y_{1,2}, y_{2,2}, y_{3,2}, ..., y_{n_2, 2}\rangle$ measurements associated with subjects in `Group 2`.

When it is obvious that first subscript (subject index) and second subscript (group index) is obviously distinguishable, the commas between the indices are omitted. When we aggregate over the subjects (as we are doing with averages), we often put a dot $\bullet$ in place of the $i$ as a placeholder.

```{r 01-04-one-IV-two-levels-vs-DV, echo = FALSE}
df_oneIV <- tribble(
  ~Control  , ~Experiment,
  "$\\overline{y}_{\\bullet 1}$",   "$\\overline{y}_{\\bullet 2}$"
)
df_oneIV <- as.data.frame(df_oneIV)
rownames(df_oneIV) <- c("DV")

col_width <- "1.5 in"
kable(df_oneIV, align = "c") %>% 
  kable_styling(c("striped", "bordered"), full_width = F) %>%
  add_header_above(c(" " = 1, "IV 1 (Treament)" = 2)) %>% 
  column_spec(seq_along(df_oneIV), width = col_width, width_min = col_width, width_max = col_width)
```

You can also be more explicit and say $\overline{y}_{\bullet,Control}$, $\overline{y}_{\bullet,Teatment}$ instead of $\overline{y}_{\bullet 1}$, $\overline{y}_{\bullet 2}$, but writing out numbered index instead of full level name is more practical if it is unambiguous that what 1 and 2 refers to. The dot ($\bullet$) is also sometimes omitted if it is obvious to do so and if it is acceptable in certain field of study.

<h3>Two IVs with two levels vs DV</h3>

When we add another IV, we can apply the same logic as 1 IV case, except the rows in the table now represent IV levels. This is called _*factorial*_ design.

```{r 01-04-two-IVs-two-levels-vs-DV, echo = FALSE}
df_twoIV <- tribble(
  ~""            ,       ~"",               ~Control,            ~Experiment,
  "IV2 (Sex)" ,    "Male", "$\\overline{y}_{11}$", "$\\overline{y}_{12}$",
  "IV2 (Sex)" ,  "Female", "$\\overline{y}_{21}$", "$\\overline{y}_{22}$"
)
df_twoIV <- as.data.frame(df_twoIV)

kable(df_twoIV, align = "c") %>%
  kable_styling(c("striped", "bordered"), full_width = F) %>%
  column_spec(1, bold = T) %>%
  column_spec(2, border_right = T)  %>% 
  add_header_above(c(" " = 1, " " = 1, "IV 1 (Treament)" = 2)) %>% 
  collapse_rows(columns = 1, valign = "middle")
```

With 2 IVs, there are three research questions (one for each IV and their interaction):

1. Does IV~1~ have an effect on the DV? (Not accounting for any other variables, such as IV~2~)
<br/>For example if DV is student's GPA and IV~1~ is traditional vs novel teaching method, does the teaching method effect GPA?

2. Does IV~2~ have an effect on the DV? (Not accounting for any other variables, such as IV~1~).
<br/><br/>
For example if DV is student's GPA and IV~2~ is student's sex, is student sex related to differences in GPA? Note that we do not use the word `effect` here because student's sex is demographic information about a student that researcher did not manipulate. Such variable is called _ex post facto_.
<br/><br/>
Such _ex post facto_ research design and is considered to be a quasi-experimental design. This variable is measuring characteristic or trait about the subject that already existed prior to researcher's intervention (`Treatment`), and using groups from such variable to compare the differences in DV is "after the fact" research.

3. Does effect IV~1~ have on DV *depend* on the value IV~2~? Conversely, does effect IV~2~ have on DV *depend* on the value of IV~1~?

<h3>Factors, Groups, and <i>Between-Subject Design</i> vs <i>Within-Subject Design</i></h3>

_*Factor*_ happens to be a synomym for IV when it takes a fixed number of values (levels). This term has a slightly deeper meaning, but let's just simplify things and say factor variable is a variable that one of the possible categorical values.

We saw that IV with 2 levels can split our subjects into two groups. If the IV had 3 or mor possible levels, then we can obviously split into 3 or more groups. In experimental design. the number of levels do not matter as much as how many IVs we have.

- *Between-Subject Design*: Experimental treatments are given to different groups of subject -- i.e. no subject can receive more than one treatment at the same time.
<br/>
In [Teacher Rating Case Study](http://onlinestatbook.com/2/case_studies/ratings.html), there is 1 IV with 2 conditions (instructor review) and 1 DV (professor rating). Students (subjects) were split into one of the two groups by IV / factor. Comparing the mean DV of one group to the mean DV of another group is effectively a comparison between (group of subjects in one condtion) vs (group of subjects in another condition). 
<br/>
Two conditions only vary by whether or not IV determined which group the subjects were assigned to. If there were no differences among subjects _between groups_, then we can interpret the IV directly effecting mean difference. If for some reason one group had particularly generous students who rated professors highly regardless, then we don't know if the mean difference in professor rating is due to the effect of instructor review condition (IV) or because of generous students. If we randomly assigned which condition a student was exposed to, then we can try to limit accidentally putting all the generous students into one group. However, this does not guarantee that there will not be any differences _between groups_. There could be another factor unknown to the researcher that is creating differences between groups.

- *Multi-factor Between-Subject Design*: same thing as Between-Subject Design with multiple IVs.

- *Within-Subject Design*: Unlike Between-Subject Design where a subject is exposed to only one of the levels for a factor (or unique combination of factors in Multi-factor Between Subject Design), each subject is exposed to all levels of a factor. This is done via applying each factor level to each subject in order. Obviously, this design is not possible for all types of factors. Sometimes once a treatment is applied, there's no reasonable way of "removing" the treatment. Time between each treatment also comes into play here.
<br/>
The order of application of factor level can also become confounding, so we _*counterbalance*_ by applying factor levels in different order for different subjects. When we consider all the subjects, the number of times a specific order was applied should be same for all possible orders.
<br/>
Because each subject is measured multiple times after different factor levels are applied, this design is often called "repeated measures" design. Within-Subject Design has an advantage that individual differences in subjects' overall levels of performance are controlled. Meaning the effect of individual subject differences on DV are removed because each subject essentially serves as its own control (e.g. each subject received both control and treatment level. The difference in DV taken after each treatment can be attributed to the most recent factor, ignoring the baseline of other subjects).

---

http://onlinestatbook.com/2/research_design/designs.html
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/01-Introduction/01-04-factors-and-groups.Rmd-->

## Measurement Scales

```{r 01-05-setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(kableExtra)
```

```{r measurement-scale-properties, echo = FALSE}
scaleProperties <- tribble(
                      ~"" ,  ~Properties,            ~`Valid Math Operations`,
  "Nominal / Categorical" ,       "None",   "$=$, $\\neq$, $\\lt$, $\\gt$",
  "Ordinal / Rank"        ,  "Magnitude",   "$=$, $\\neq$, $\\lt$, $\\gt$",
  "Interval"              ,  "Magnitude",   "$=$, $\\neq$, $\\lt$, $\\gt$",
  "Interval"              ,  "Interval" ,   "$=$, $\\neq$, $\\lt$, $\\gt$",
  "Ratio"                 , "Magnitude" ,   "$=$, $\\neq$, $\\lt$, $\\gt$",
  "Ratio"                 , "Interval"  ,   "$=$, $\\neq$, $\\lt$, $\\gt$",
  "Ratio"                 , "Absolute 0",               "$x_{1} / x_{2} = k$"
)
scaleProperties <- as.data.frame(scaleProperties)

col_width <- "1.5 in"
kable(scaleProperties, align = "c") %>% 
  kable_styling(c("striped", "bordered"), full_width = F) %>%
  column_spec(1, bold = T, border_right = T) %>% 
  collapse_rows(columns = 1, valign = "middle")
```

<h3>Nominal (categorical) scales</h3>

The categories are mutually exclusive and exhaustive. The categories have no meaning by themselves â€“ the placement of an observation in a particular category simply indicates that it is different from observations in other categories. It does not imply one category is more or less different.

- Examples: Car model name, eye color

Nominal cannot normally distributed.

<h3>Ordinal (rank) scales</h3>

Ordinal scales are like nominal scales with additional property of order among the categories included on the scale.

- Examples: social class, _*percentile ranks*_, and Olympic medal placing.

With ordinal scales, we can talk about the order of a set of objects, but we cannot say *how much bigger* one category is to another.
<br/>
Ordinal cannot normally distributed.

<h3>Interval scales (equi-interval scales)</h3>

Sometimes called equi-interval scales to distinguish this level of measurement from nominal and ordinal scales.

This scale can be added, subtracted, multiplied, and divided *without affecting the relative distances among scores.*. The intervals between two scores can be determined by arithmetic manipulation of the scores.


An important characteristic of interval scales is that the zero point is arbitrary, which means that we cannot meaningfully interpret the size of particular score ratios. As a consequence of being measured on equi-units, it is possible for interval data to be normal under asymptotic assumptions. This is just a fancy way of saying that variables measured in interval scales have _*central tendency*_ that can be measured by mode, median, or mean. Standard deviations for these variables can also be calculated.

> Some would argue that centeral tendency for nominal and ordinal data can be calculated via mode. For practical purposes, I think that is valid, but in purist sense, I don't think central tendency is defined for nominal and ordinal data.

- Examples: Temperature scale like Celcius, Farenheit
<br/>
10 C^o^ vs 20 C^o^ and 20 C^o^ vs 30 C^o^: the degrees are 10 units apart, but just because $\frac{20}{10}=2$, it doesn't mean 20 C^o^ is $2 \times 10$ C^o^.
<br/>
Your local weather report might say today's weather (20 C^o^) is twice as hot as yesterday's weather (10 C^o^), but that would be wrong because Celcius scale has no concept of ratio! This has to be with the fact that there is no meaningful $0$ in Celcius. Celcius scale does have 0 to represent freezing point, but this is not a true 0 that represents absence of something, unlike Kelvin scale where 0 is complete absence of molecular motion. Therfore ...

- Not an example: Kelvin
<br/> Kelvin is not an interval scale. It is a _ratio scale_ because it has properties of interval scale with absolute zero. If two liquids have 10 Kelvin and 20 Kelvin respectively, that does indeed mean the latter is is twice as the former.

<h3>Ratio scales</h3>

Ratio scales have all the properties of interval scales with addition of an absolute zero. 

- distance and time measures have genuine zero points.

This is what people most generally mean by "numeric" column
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/01-Introduction/01-05-measurement-scales.Rmd-->

# Summary Statistics
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/02-Summary-Statistics/02-00-Summary-Statistics.Rmd-->

## Limits & Rounding

```{r 01-01-setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(kableExtra)
```

<h3>Limits</h3>

When we measure something with numbers, we are actually speaking in terms of limits based on our _unit of measurement_. \@ref(tab:01-01-number-limit) shows that when we measure something as $x_{i}$ (for person or observation index, $i$) equals to some value, then what this really means that "$x_{i}$ was measured via $x_{\bullet, \text{unit of measurement}}$, and the value of $x_{i}$ is within the range of $(x_{i,LL}, x_{i,UL})$". The unit of measurement ($x_{\bullet, \text{unit of measurement}}$) is constant for all observations because we assume that all observations were measured with the same level of precision. This is probably true in most cases.

```{r 01-01-number-limit, echo=FALSE}
kable(
  tribble(
    ~`$x_{i}$`, ~`$x_{\\bullet, \\text{unit of measurement}}$`, ~`$\\frac{1}{2}$ of $x_{\\bullet, \\text{unit of measurement}}$`, ~Lower, ~Upper,
     3, 1, 0.5, 2.5, 3.5,
     7, 1, 0.5, 6.5, 7.5,
    10, 1, 0.5, 9.5, 10.5,
  ), 
  caption = 'Example of measurement at 1 unit of measurement',
  booktabs = TRUE, align = "c") %>%
  kable_styling(c("striped", "condensed", "bordered"), full_width = F) %>%
  add_header_above(c(" " = 1, " " = 1, " " = 1, "Exact Limits" = 2))
```

An example of this is measuring something by counting. You have 3 pencils, 7 apples, and 10 fingers. What you are really doing is saying "I have somewhere between 2.5 and 3.5 pencils, 6.5 and 7.5 apples, and 9.5 and 10.5 fingers". It seems silly to say you have somewhere between 6.5 and 7.5 apples, but what really is a whole apple? If I have one small apple and one big apple, then you would have said that you have 2 apples, but the sizes of apples are so different! It is just that we as society decided to systematically count objects as whole numbers and not always speak in ranges of possible values because of uncertainty.

Some more examples with different number of units.

```{r 01-01-number-limit-2, echo=FALSE}
df_number_limit_2 <- tribble(
  ~`$x_{i}$`, ~`$x_{\\bullet, \\text{unit of measurement}}$`, ~`$\\frac{1}{2}$ of $x_{\\bullet, \\text{unit of measurement}}$`, ~Lower, ~Upper,
  " 3.0 ", 0.1, 0.05, 2.95, 3.05,
  " 7.5 ", 0.1, 0.05, 6.95, 7.05,
  "10   ", 0.1, 0.05, 9.95, 10.05,
  
  " 3.49",  0.01, 0.005, 3.485, 3.495,
  " 7.5 ",  0.01, 0.005, 7.495, 7.505,
  "10.61", 0.01, 0.005, 10.605, 10.615
)
df_number_limit_2[[1]] <- str_replace_all(df_number_limit_2[[1]], " ", "&nbsp;")
kable(
  df_number_limit_2,
  caption = 'Example of measurement at 1 unit of measurement',
  booktabs = TRUE, align = c("r","c","c","c","c"), escape=F,
) %>%
  kable_styling(c("striped", "bordered"), full_width = F) %>%
  add_header_above(c(" " = 1, " " = 1, " " = 1, "Exact Limits" = 2)) %>% 
  pack_rows(" ", start_row = 4, end_row = 6, label_row_css = "text-align: center;")
```

<h3>Rounding</h3>
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/02-Summary-Statistics/02-01-Measurement-Limits.Rmd-->

## Frequency


```{r 02-02-setup-cache, echo=FALSE, message=FALSE, cache=T}
df_chips <- readRDS("data/chocochip_2019.rds")
```


```{r 02-02-setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(kableExtra)
```


Table \@ref(tab:02-02-chocochip-table) shows the number of chocolate chips in a Chips Ahoy cookie measured by 33 graduate students. Each person (`Id`) measured his/her own cookie twice (`Time_1` and `Time_2`). Prior to collecting this data, the students discussed what ~counts as~ is considered a single chocolate chip. This is actually more difficult than you think because chocolate chips in a cookie comes in different sizes and shapes (individual chip or meleted and merged together as giant glob).


```{r 02-02-chocochip-table, echo=FALSE}
col_width <- "1.5 in"
df_chips_prevew <- bind_rows(
    head(df_chips, n=3),
    tail(df_chips, n=3)
  )
colnames(df_chips_prevew) <- c("Id", "Time~1~", "Time~2~")
kable(
  df_chips_prevew,
  booktabs = TRUE, caption = '<br/>
  Number of Chocolate Chips<br/>
  Measured by Fall 2019 Class'
) %>%
  kable_styling(bootstrap_options = c("striped","condensed"), full_width = F) %>% 
  column_spec(seq_along(df_chips), width = col_width, width_min = col_width, width_max = col_width) %>% 
  pack_rows("...", start_row = 4, end_row = 6, label_row_css = "text-align: center;")
```

Let's create a frequency table for measurement at time 1 with this dataset.

Here are the steps to create a frequency table:

<!-- Step 1 -->

1. Find the highest value and the lowest value of our measured values. We often refer measurement as a _*score*_ and use Greek letters to denote variable, like $x$, to represent these scores as a vector of value.
<br/>
<br/>
In our chocolate chip example, the highest value is 32 and the lowest is 9 for measurements at time 1. We will only look at Time~1~ value for now

---

<!-- Step 2, two column -->

2. Count down from the highest value to the lowest value by [__measurement unit__][Limits & Rounding] intervals. Put this sequence in column $x$ of our frequency table in decreasing order.  
<br/>
__*measurement unit*__: precision width of your measurement, in most cases $1$ since we measure counts by whole numbers. This may seem trivial because what else could it be other than $1$? Well, this is because we (humans) count numbers by whole numbers, and we are conditioned to think this way. In reality, we made a preliminary decision to what constitutes as 1 chocolate chip versus 2 chocolate chips. In this scenario, it is not possible to measure 1.5 chocolate chips. Note that we are not saying it is impossible to count 1.5 chips -- we would just have to define what this is. The 1-vs-2-chips concept is something that we invented for our __measurement__ of the construct of __chocolate chip__. We as a society "agreed" on a systematic procedural way to count chocolate chips.  
<br/>
If we had a agreed on measuring the magnitude of chocolate chip at $0.5$ intervals, then we would count down by $0.5$ instead. 


```{r 02-02-chocochip-freq-table-step2-echo, eval=FALSE, echo=TRUE}
# Step 2: Generate dataset over all measurement unit
chocochip_unit <- 1 # measurement unit
x <- sort(seq(min(df_chips$Time_1), max(df_chips$Time_1), by = chocochip_unit), decreasing = T)
df_freq <- tibble(x = x)
```


---

<!-- Step 3, two column -->

3. For each row value of column $x$, count the number of times that value appeared in our measurement. Put this value in column $f$ (for frequency) in our table.

```{r 02-02-chocochip-freq-table, echo=FALSE}
# Step 2
chocochip_unit <- 1
x <- sort(seq(min(df_chips$Time_1), max(df_chips$Time_1), by = chocochip_unit), decreasing = T)
df_freq <- tibble(x = x)

# Step 3
df_freq <- as_tibble(
  as.data.frame.table(
    table(x = factor(df_chips$Time_1, levels = df_freq$x)), 
    responseName='f')
)

# Step 4
df_freq <- df_freq %>% 
  arrange(desc(x)) %>%
  mutate(cf = cumsum(f)) %>% 
  arrange(x)

col_width <- "1 in"
kable(df_freq,
      caption = '<br/>Step 3 - 4') %>%
  kable_styling(bootstrap_options = c("striped", "condensed"), 
                full_width = F, position = "float_right") %>% 
  column_spec(seq_along(df_freq), width = col_width, width_min = col_width, width_max = col_width) %>% 
  footnote(general = "Note the 0 in frequency column\nwhen `x` was not measured.")
```

Note that some frequency counts are 0, for exampe $x = 31$. This is because none of the observers (33 students) did not measure instances of 31 chocolate chips in their cookies. This does not mean Chips Ahoy company does not make cookies with 31 chocolate chips. It just means that we failed to observe such instance due to __sampling error__. If we had measured all the cookies produced by the company (i.e. __*population*__ of all cookies) and repeated the measurement experiment, we would know whether there truly wasn't a single cookie with 31 chips. In our __*sample*__ of 33 cookies, we don't know if $f = 0$ if $x = 31$ is due to chance. In the __*population*__ of all cookies, we would know for a fact that $f = 0$ if $x = 31$ because we have the measurement for the entire population.  
<br/>
Also note that saying "This cookie has 1 'chocolate chip'" is equivalent to saying "This cookie has somewhere between 0.5 and 1.5 'chocolate chip'". The former is a very strong statement that cannot possibly be true, as we genuinely can't know what __exactly__ 1 choclate chip is. The latter is a statement that communicates uncertainty due to __*measurement error*__ of our procedural way to count chocolate chip.  
<br/>
This "procedural way to count chocolate chip" is also called __*operationalization*__ of chocolate chip. To be more generic, "number of chocolate chip" is an example of a __*construct*__. Contruct is a broad concept or topic of study interest. Another examples of constructs in non cookie-factory context is "intelligence". Just like how "number of chocolate chip" can be a difficult thing to define and measure, "intelligence" is difficult to define and measure. Our measurement error comes from various sources, including how we define these constructs and how we operationalize them.

```{r 02-02-chocochip-freq-table-step3-echo, eval=FALSE, echo=TRUE}
# Step 3: Calculate frequency over min to max of x, for each measurement unit
# Count # of times each Time_1 value appeared in our x, and put the counts in column f
df_freq <- as_tibble(
  as.data.frame.table(
    table(x = factor(df_chips$Time_1, levels = df_freq$x)), 
    responseName='f')
)
```

---

<!-- Step 4-->

4. Calculate the cumulative frequency and save to our table as $cf$. To do this, we sum up the frequency $f$ in the ascending ordered values of $x$ (lowest value to highest value). Note that in the R code using `library(dplyr)`, we are ordering x in __descending__ order due to the vocabulary of `tidyverse` context (In `tidyverse` table, `tibble`, we are ordering the table rows from top to bottom. Hence, having lowest value of $x$ as first row and highest value of $x$ on the last row is arranging table in descending order).

```{r 02-02-chocochip-freq-table-step4-echo, eval=FALSE, echo=TRUE}
# Step 4: Calculate cumulative frequency
df_freq <- df_freq %>% 
  arrange(desc(x)) %>% # cumulative sum requires ordered x from smallest to highest
  mutate(cf = cumsum(f)) %>% 
  arrange(x)
```


It looks like we are simply taking a running sum of frequency, but it is very important to understand the meaning of cumulative frequency, especially in terms of limits as per [Limits & Rounding]. 
<br/>
&nbsp;_Cumulative frequency_ by definition is the frequency of scores falling at or below the upper limit of a score. 
<br/>
You probably were exposed to cumulative frequency in terms simpler definition of "the frequency by which the observed values X are less than or equal to Xr." ([Wikipedia - Cumulative Frequency Analysis](https://en.wikipedia.org/wiki/Cumulative_frequency_analysis)) ~~and/or somehow equated it as discrete version of similar concept from probability distribution as Cumulative Distribution Function (CDF)~~. What you previously know about cumulative frequency is valid, but you should augment that prior knowledge with the concept of measurement and uncertainty. Remember, a score of $x_{i}$ doesn't actually mean "Observation $i$ scored exactly $x_{i}$." It is more appropriate to say "Observation $i$ scored somewhere between $(x_{i} - \frac{1}{2}$ of $x_{\bullet, \text{unit of measurement}})$ and $(x_{i} + \frac{1}{2}$ of $x_{\bullet, \text{unit of measurement}})$."

```{r 02-02-chocohip-freq-table-step5, echo=FALSE}
df_freq_with_limit <- df_freq %>% 
  mutate(`$(x_{LL} - x_{UL})$` = 
           paste0("(", as.numeric(as.character(x)) - chocochip_unit / 2, " - ",
                  as.numeric(levels(x)) + chocochip_unit / 2, ")"))
df_freq_with_limit <- df_freq_with_limit %>% select(c(4, 1:3))
kable(df_freq_with_limit) %>% 
   kable_styling(bootstrap_options = c("striped", "bordered"), full_width = F, position = "float_left")
```

By adding the concept of limits, we can further elaborate on concepts like _range_ that goes beyond what you have probably have learned as "maximum value - minimum value + 1". What range really is:

\begin{align*} 
range(X) &= max(x_{UL}) - min(x_{LL}) + class\ width \\
class\ width &= x_{UL} - x_{LL}
\end{align*} 


In the most cases where we compute frequency by whole number counts, class width is just equal to the measurement unit which is just 1. That is why the simple rule that you have learned as "max - min + 1" works. It actually is a simplification of this concept. The reason why we use class width instead of simply using "1" will make sense when we create _grouped frequency_. In short, the range definition with _class width_ is a generalization of "max - min + 1" that works for cases when our unit of measurement is not 1.
<br/>
So
---

<!-- Step 5-->

5. Calculate the proportion (relative frequency) of each $x$ by dividing frequency, $f$, by sum of all frequencies (or equivalently, the max of cumulative frequency). Similarly, calculate the cumulative proportion by dividing cumulative frequency, $cf$, by sum of all frequencies.


```{r 02-02-chocochip-freq-table-step5-echo, eval=FALSE, echo=TRUE}
# Step 5: Calculate relative
df_freq <- 
  df_freq %>% 
  mutate(p = f / max(cf),
         cp = cf / max(cf))

```



```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/02-Summary-Statistics/02-02-Frequency.Rmd-->

# Distributions
```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/03-Distributions/03-00-Distributions.Rmd-->

## Total Score & Difficulty

Item difficulty $p_i$ is defined as probability of test takers answering the item $i$ correct. This is estimated by $p_i = \frac{\text{# of test takers who answered correctly}}{\text{total # of test takers}}$. Let's take a look at the relationship between $p_i$ and total score (sum of number of items correct, equally-weighted). In the following simulation, 15-item tests are administered to 1000 people. Different tests have different levels of difficulties for the underlying items.


```{r 03-01-setup-cache, echo=FALSE, message=FALSE, cache=T}
# df_kurtosis_difficulty <- list(
#   df_p02 = make_test_score_df(item_n = 15, person_n = 1000, prob = 0.02),
#   df_p25 = make_test_score_df(item_n = 15, person_n = 1000, prob = 0.25),
#   df_p50 = make_test_score_df(item_n = 15, person_n = 1000, prob = 0.50),
#   df_p75 = make_test_score_df(item_n = 15, person_n = 1000, prob = 0.75),
#   df_p98 = make_test_score_df(item_n = 15, person_n = 1000, prob = 0.98),
#   df_p02_p98 = make_test_score_df(item_n = 15, person_n = 1000, prob = c(0.02, 0.98)),
#   df_p02_p50_p98 = make_test_score_df(item_n = 15, person_n = 1000, prob = c(0.02 , 0.50, 0.50, 0.50, 0.98))
# )
# saveRDS(df_kurtosis_difficulty, "data/df_kurtosis_difficulty.rds")
df_kurtosis_difficulty <- readRDS("data/df_kurtosis_difficulty.rds")
```


```{r 03-01-setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(ggplot2)
```

<details><summary>Code to simulate tests taken</summary>

```{r 03-01-simulation-code, echo=TRUE, collapse = T}
# For a test with "item_n" number of items, 
#   generate a dataset where "person_n" number of people answered the 15 items.
# For all people, each item has "prob" probability of answering correctly.
#   The vector of "prob" recycles to all the items.
#   For example, 
#    "prob = 0.5" means all items have 50% chance of correct
#    "prob = c(0.25, 0.75)" means item 1 has 25% chance, item 2 has 75% chance, 
#                                 item 3 has 25% chance, item 4 has 75% chance, 
#                                 ... until you run out of item
make_test_score_df <- function(item_n, person_n, prob = 0.5) {
  if (length(prob) == 1) {
    df <- sapply(seq_len(item_n), function(i) { rbinom(person_n, size = 1, prob = prob) })
  } else {
    # if prob for all items not specified, recycle to the length of item_n
    prob <- rep_len(prob, item_n)
    res <- lapply(seq_along(prob), function(i) {
      rbinom(person_n, size = 1, prob[i])
    })
    df <- matrix(unlist(res), ncol = item_n, nrow = person_n, byrow = F)
  }
  
  colnames(df) <- paste0(rep("Item ", item_n), seq_len(item_n))
  
  df <- df %>% as_tibble() %>% 
    mutate(Person =  paste0(rep("Person ", person_n), seq_len(person_n))) %>% 
    pivot_longer(cols = 1:15, names_to = "Item") 
  
  df
}

# Create Density Plot for simulated dataset
make_test_score_plot <- function(df, item_n, person_n, subtitle = "") {
  df_Score_by_Person <- df %>% 
    group_by(Person) %>% 
    summarise(
      Score = sum(value)
    )
  as_tibble(
    df_freq <- as.data.frame.table(
      table(Score = factor(df_Score_by_Person$Score, levels = seq(0, item_n, by = 1))), 
      responseName='Frequency'))
  df_freq %>% 
    mutate(RelativeFrequency = Frequency/person_n,
           Score = as.numeric(as.character(Score))) %>% 
    ggplot(aes(x = Score, y = RelativeFrequency)) +
    geom_point() + geom_line() +
    scale_x_continuous(name = "Score", 
                       breaks = seq(0, item_n, by = 1),
                       minor_breaks = seq(0, item_n, by = 1), 
                       limits = c(0, item_n)) + 
    stat_function(fun = dnorm, 
                  args = list(mean = item_n * 0.5, sd = item_n * 0.5 * (1-0.5)), # expected normal distribution at p = 0.5
                  col = "red") + 
    ggtitle(label = paste0("Distribution of Test Scores for ", person_n, " test takers."),
            subtitle = subtitle) +
    ylab("Relative Frequency")
}
```

</details>

Now we generate 15-item test administered to 1000 people and plot the total score against theoretically normally distributed total score. Note the diffculty $p_i$ (`prob` in the R code)

```{r 03-01-df-p25-echo, eval=FALSE, echo=TRUE}
df_p25 <- make_test_score_df(item_n = 15, person_n = 1000, prob = 0.25)
make_test_score_plot(df_p25, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.25," (hard)"))))
```

```{r 03-01-df-p25, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p25, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.25," (hard)"))))
```

Items have hard difficulty (25% chance of correct), so the total score for test takers are right skewed.

```{r 03-01-df-p50-echo, eval=FALSE, echo=TRUE}
df_p50 <- make_test_score_df(item_n = 15, person_n = 1000, prob = 0.50)
make_test_score_plot(df_p50, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.50," (medium)"))))
```

```{r 03-01-df-p50, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p50, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.50," (medium)"))))
```

Items have medium difficulty (50% chance of correct), so the total score for test takers are normally distributed.

> TODO compare kurtosis?

```{r 03-01-df-p75-echo, eval=FALSE, echo=TRUE}
df_p75 <- make_test_score_df(item_n = 15, person_n = 1000, prob = 0.75)
make_test_score_plot(df_p75, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.75," (easy)"))))
```

```{r 03-01-df-p75, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p75, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.75," (easy)"))))
```

Items have east difficulty (75% chance of correct), so the total score for test takers are left skewed.

```{r 03-01-df-p02-echo, eval=FALSE, echo=TRUE}
df_p02 <- make_test_score_df(item_n = 15, person_n = 1000, prob = 0.02)
make_test_score_plot(df_p02, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.02," (very hard)"))))
```

```{r 03-01-df-p02, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p02, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.02," (very hard)"))))
```

Items have very hard difficulty (2% chance of correct), so the total score for test takers are highly right skewed. This test isn't useful (Other than maybe identifying that one-in-a-million genius. Regardless, this test is not discriminatory).

```{r 03-01-df-p98-echo, eval=FALSE, echo=TRUE}
df_p98 <- make_test_score_df(item_n = 15, person_n = 1000, prob = 0.98)
make_test_score_plot(df_p98, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.98," (very easy)"))))
```

```{r 03-01-df-p98, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p98, item_n = 15, person_n = 1000, subtitle = (expression(paste("All items: ", p[i], " = ", 0.98," (very easy)"))))
```

Items have very easy difficulty (98% chance of correct), so the total score for test takers are highly left skewed. This test isn't useful because everyone will get perfect or near perfect scores.

---

So what is an ideal test? A good mixture of items varying diffculty around 0.30 - 0.70 (for average of 0.5). 


But if we are targeting ~0.50 for all items taken together, why not alternate between very hard ($p_i = 0.02$) and very easy  ($p_i = 0.98$) for the ~0.50? Wouldn't that lead to the same thing?

```{r 03-01-df-p02-p98-echo, eval=FALSE, echo=TRUE}
# Leptokurtic distribution of test scores bc items are too hard or too easy
df_p02_p98 <- make_test_score_df(item_n = 15, person_n = 1000, prob = c(0.02, 0.98))
make_test_score_plot(df_p02_p98, item_n = 15, person_n = 1000, 
                     subtitle = (expression(paste("All items: ", p[i]," = 0.02 or ", p[i], ", = 0.98 (very hard or very easy)"))))
```

```{r 03-01-df-p02-p98, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p02_p98, item_n = 15, person_n = 1000, 
                     subtitle = (expression(paste("All items: ", p[i]," = 0.02 or ", p[i], ", = 0.98 (very hard or very easy)"))))
```

The simulation shows that the total score distribution is piling up in the middle, creating highly leptokurtic distribution. To fix this, you have to add more *MEDIUM LEVEL* items to <u>distribute item's contribution to the total score to both ends of the total score</u>

```{r 03-01-df-p02-p50-p98-echo, eval=FALSE, echo=TRUE}
# To fix, add more moderate difficutly tests
df_p02_p50_p98 <- make_test_score_df(item_n = 15, person_n = 1000, prob = c(0.02 , 0.50, 0.50, 0.50, 0.98))
make_test_score_plot(df_p02_p50_p98, item_n = 15, person_n = 1000, 
                     subtitle = (expression(paste("All items: ", p[i]," = {0.02 , 0.50, 0.50, 0.50, 0.98}"))))
```

```{r 03-01-df-p02-p50-p98, eval=TRUE, echo=FALSE, cache=T}
make_test_score_plot(df_kurtosis_difficulty$df_p02_p50_p98, item_n = 15, person_n = 1000, 
                     subtitle = (expression(paste("All items: ", p[i]," = {0.02 , 0.50, 0.50, 0.50, 0.98}"))))
```

At first, you might think "If too many people are scoring ~7.5 (50% of possible max 15), then why should the items be medium diffculty such that 50% of the test takers would answer correctly? Shouldn't I add more easy / hard items?" Well in the simulation example \@ref(03-01-df-p02-p98), we took "add more easy / hard items" to the extreme where all items were only very easy or very hard. This distribution happens because score is the *total sum* of individual item's correct (1) or incorrect (0). If half of the items were very hard, the sum of those very hard items would be 0 or near 0. On the other hand, the other half of very easy items would have sum of 7 or nearly 8 (or ~8, because we have odd number of items). When you add these halves togehter, the total score hovers around the middle score of ~7.5.


```{r include=FALSE, cache=FALSE}
# https://github.com/rstudio/bookdown/issues/418#issuecomment-314265432

# detach packages
packages = sapply(sessionInfo()$otherPkgs, function(x) x$Package)
packages = packages[packages != "bookdown"]
packages = sapply(packages, function(p) paste0("package:", p))
lapply(packages, detach, character.only = TRUE, unload = TRUE)
# clear environment
rm(list = ls())
```

<!--chapter:end:content/03-Distributions/03-01-Total-Score-Difficulty.Rmd-->

